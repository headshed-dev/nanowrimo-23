- this to do with restul apis, nestjs is one of the most respected ( according to my reading so far ) restapi frameworks
	- it is nodejs, typscript and based on expressjs but also can do fastify, yet another
		- Fastify isÂ **a web framework highly focused on providing the best developer experience with the least overhead and a powerful plugin architecture**. It is inspired by Hapi and Express and as far as we know, it is one of the fastest web frameworks in town.
		  id:: 65493270-0601-4e8d-8f79-26d580a58393
	- I think this fits in sort of with writings to do with monitoring as something not done yet is webcheck, I think I can use that name as they have now stopped using it entirely which used apache, cgi and ssl ( tls to you an me today ) plus further encryptions with PGP made it quite difficult for network security to read it- which is why they didnt like it in my opinion
	- seeing as I was reading the first O'Reilly text on restful APIs post to Y2K I think this pertinent as we were using 'GET' predominately with parameters to do much of what is available to RESTful GET, POST, et. al. in the 'modern day' so we were ahead of the curve on that one, thanks to Mr John Connor
	- in this video
		- by **Marius Espejo** who featured a playlist with [netninja nestjs crash course](https://www.youtube.com/watch?v=pcX97ZrTE6M&list=PL4cUxeGkcC9g8YFseGdkyj9RH9kVs_cMr)
			- {{video https://www.youtube.com/watch?v=nY0R7pslbCI}}
		- my interest with nestjs is renewed, having worked a project in Go and React that lacks any of this build pattern, let alone the capabilities that NextJS has built in from the get go
		- following from this is the series in flight by Dave Gray so far
			- part 1
				- {{video https://www.youtube.com/watch?v=juNVinepwKA&t=9s}}
			- part 2
				- {{video https://www.youtube.com/watch?v=otw0zQ0NSa4}}
		- as for hosting, I would go for my own vm, docker and local file store or encrypted buckets for current use cases but another interesting approach is to go for a variety of BaaS providers for which [back4app](https://blog.back4app.com/nest-js-hosting-providers/) themselves a BaaS summarize a number of options in this regard, some are even free forever tier, offering zero cost start up and possibly not-for-profit / charity options
- I tried to take a look at go restapi, with the vain hopes to get swagger working with the app we currently have and found a youtube video from only 6 months ago, which you would have thought would work but no, it fails miserably, needing to downgrad 10 versions of swag as the ones after this break, creating code that does not even compile so totally useless
	- _Swagger for Go REST APIs Quick & Easy Documentation with Gin Comprehensive Walkthrough_
	  [here](https://www.youtube.com/watch?v=0b_N4y8_9iI&list=WL&index=11&t=48s) dont be fooled by the title, I had to downgrade swag for it to even create code that compiles with `swag init` I dont think the person doing the video has tested with a recent version of go, he fails to do imports in the demo and has to backtrack, basic stuff like typing imports to have them trashed on file - save. But non the less very annoying to have wasted time on this but somthing tells me I've been barking up the wrong tree with Chi - a recommendation from another youtuber that has let me down when trying to get swagger working with a go api
	- as FastAPI does this out of the box, why can't a go framework just do this
	- I understand your frustration with the outdated or incompatible versions of the swag and gin-swagger tools. I have searched the web for a reliable example of getting started with Go, Gin and Swagger that actually works with the latest versions of these tools. Here is what I found:
	- [How to Integrate Swagger UI in Go Backend - Gin Edition](^2^) by Santosh Kumar. This is a detailed tutorial that shows how to set up Swagger UI for a Go Gin project using swag v1.7.9 and gin-swagger v1.3.1. It also explains how to add annotations, customize the Swagger UI, and use the Swagger Editor to validate the documentation.
	- [Documenting Go web APIs with Swag](^4^) by Francis Sunday. This is another comprehensive guide that demonstrates how to use swag v1.7.9 and gin-swagger v1.3.1 to create Swagger documentation for a Go Gin API. It also covers how to use the swag init command, how to structure the code, and how to test the API with Postman.
	- [How to add Swagger in Golang Gin](^3^) by Lemoncode21. This is a shorter and simpler tutorial that shows how to use swag v1.7.9 and gin-swagger v1.3.1 to add Swagger documentation to a Go Gin project. It also provides a video and a Github repository with the source code.
	  
	  I hope these examples help you get started with Go, Gin and Swagger without having to downgrade the swag command line tool. ðŸ˜Š
	  
	  Source: Conversation with Bing, 07/11/2023
	  (1) How to Integrate Swagger UI in Go Backend - Gin Edition. https://santoshk.dev/posts/2022/how-to-integrate-swagger-ui-in-go-backend-gin-edition/.
	  (2) Documenting Go web APIs with Swag - LogRocket Blog. https://blog.logrocket.com/documenting-go-web-apis-with-swag/.
	  (3) How to add Swagger in Golang Gin. | by Lemoncode21 | Medium. https://lemoncode21.medium.com/how-to-add-swagger-in-golang-gin-6932e8076ec0.
	  (4) GitHub - swaggo/gin-swagger: gin middleware to automatically generate .... https://github.com/swaggo/gin-swagger.
	  (5) Getting Started with Swagger: An Introduction to Swagger Tools. https://swagger.io/resources/webinars/getting-started-with-swagger/.
	  (6) undefined. https://github.com/swaggo/swag.
	- netsjs could be our only hope aside of fastAPI
		- Yes, NestJS can create Swagger documentation for your REST API using the @nestjs/swagger module. This module allows you to generate a specification that conforms to the OpenAPI standard by using decorators. You can also use the Swagger UI to interact with your API and view the documentation in a browser. To learn more about how to set up Swagger in your NestJS app, you can check out these web resources:
		- [OpenAPI (Swagger) | NestJS - A progressive Node.js framework](^1^)
		- [GitHub - nestjs/swagger: OpenAPI (Swagger) module for Nest framework (node.js)](^2^)
		- [Adding live documentation to YOUR REST API with Swagger and NestJS](^3^)
		- [Generate API Documentation Using Swagger Module in NestJS - LUKI NOTES](^4^)
		- [Swagger API Documentation Tips and Tricks in NestJS - Trilon](^5^)
		  
		  Source: Conversation with Bing, 07/11/2023
		  (1) OpenAPI (Swagger) | NestJS - A progressive Node.js framework. https://docs.nestjs.com/recipes/swagger.
		  (2) GitHub - nestjs/swagger: OpenAPI (Swagger) module for Nest framework .... https://github.com/nestjs/swagger.
		  (3) Adding live documentation to YOUR REST API with Swagger and Nest.js. https://dev.to/itnext/adding-live-documentation-to-your-rest-api-with-swagger-and-nest-js-211e.
		  (4) Generate API Documentation Using Swagger Module in NestJS - LUKI NOTES. https://www.lukinotes.com/2022/05/nestjs-generate-swagger-api-documentation.html.
		  (5) Swagger API Documentation Tips and Tricks in NestJS - Trilon. https://trilon.io/blog/nestjs-swagger-tips-tricks.
		  (6) undefined. https://nestjs.com.
- {{renderer :wordcount_}}
	- If your in any way aware of technology you will have heard the phrase API, meaning Application Program Interface and another closely associated RESTful API to quote AWS pages
		- Representational State Transfer (REST) is a software architecture that imposes conditions on how an API should work. REST was initially created as a guideline to manage communication on a complex network like the internet. You can use REST-based architecture to support high-performing and reliable communication at scale. You can easily implement and modify it, bringing visibility and cross-platform portability to any API system.
	- Other technologies merge and flux with this and add to a cloud of buzz words, tRPC is getting a lot of noise recently with headlines like
		- > Move Fast and Break Nothing.
		  End-to-end typesafe APIs made easy.
		  Experience the full power of TypeScript inference to boost productivity
		  for your full-stack application.
	- Graphql is another stating that
		- > GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developerÂ tools.
	- While we're at it lets not forget gRPC from google
		- >A high performance, open source universal RPC framework
	- These are a snapshot of what I'm currently keeping an eye on that I bring to mind just now suffice to say there is always a lot of stuff going on.
	- I noticed, as did many bigger better minds than this little bear, that there are common issues we are faced with and patterns that tend to repeat themselves when building APIs.
		- We tend to pronounce API as the letters, A, P, I by the way, so you don't embarass yourself talking to a tech guru by saying 'whats an appy?' - a little amusing anectdote I recall from a respdected colleague remarking at this in regards to an amusing occurence in our work one day. I hope he is doing well, I get to meet a lot of bright, clever and dynamic people and he was one of them that shone brightly. When I'm feeling low or depressed I can recall good times and interactions with some in a busy work life, not always mind, but some stand out and that is one of them.
	- A framework that some use in environments developed using NodeJS called NestJS I like as it takes these ideas and formalises them in a way that we can adopt in our API projects that follow these well known, well trod paths.
	- I think that some of the attraction of becoming a programmer in particular but perhaps more generally, wanting to be seen as a 'wizz with computers' as I've heard and smiled with gritted teeth in the past is that there is a perception at least that when you become this mythical creature that you will have ultimate freedom to do things in a way that you see best and let your creative juices flow so to speak. I shudder at the thought of this. That the world is one seen through rosy colored lenses and magical rainbows with unicorns dancing in the distance. I'm certain this mental state exists in the minds of some.
	- It is prefereable in my view to adopt core principles in the way that we do things in order to learn from our and others before us mistakes. This way we are less likely to fall foul of some of the disasters that are otherwise sure to befall us.
	- Feature creep is a phrase I oft recall and see it seep into my conciousness when we fail to focus on the task at hand.
	- Feature creep is where a project keeps getting 'features' added to it whilst it is being created and developed. This is not all together a bad thing but uncontrolled can lead to a project never being delivered, which is my definition of a total failure
	- Staying focussed Is I believe a core principle of agile where we structure our working pattern to be in limited time 'sprints' in which a focus of effort is put into delivering a set of agreed goals. Short timed sprints like this allow us to focus on the job in hand rather than be pulled in all directions by overly abitious stakeholders but allows for a ballance of time and effort verses flexibility towared ambitious goals that change and morph from one day to the next even. From the position of the coder to the person that is paying for their time, each have valid points of view and each need to be heard and acted upon. Following patterns that are known to work can begin to resolve some differences and conflicts even where as doing the same thing that is known to fail I believe would be a definition of insanity.
	- NestJS has been described as the 'AngularJS' of restul API frameworks. I'd sort of agree with this but only up to a point. What is meant by this is that another framework, this time of a front end framwork that is used to develop reactive single page applications and reactive front end applications, once called AngularJS, deveoped and made open source by teams in Google was once set to be the defacto in its class. I, like many others, dove into its code, believing it to be the secret sauce, the future of UI and heralded a new era in web technology. Much of this was true but what happened was Google decided to drop AngularJS and start a completely new project they called Angular, so the work we had all put into learning the one with 'JS' at the end of it was for the most part redundant, we'd have to learn all over again. Companies had already invested in this technology and built and deployed applications in AngularJS. I worked on one of them at the tail end of its existence, post to its being made obsolete for some time. Yet there were still developers actively involved in its support and development right up to the point it was replaced by React, another framework for the same purpose, developed and made open source by Facebook, or Meta as they prefer to be called now.
	- A person that worked at Google at one point by the name of Evan You, himself thought there was a better way to create web front end framworks and indeed that there were some good parts of AngularJS that could be salvaged and he started a project called VueJS. I jumped to learning Vue as I felt that by doing so I was able to grab back some of the mind share I had given to AngularJS. So at least I got to learn 2 frameworks as a result. Learning new things helps expand our knowlege and is not always a wanton waste of time, however I think that there needs to be a balance and we only have so much time left on this earth to do what we are doing right now, so we need to be careful how we spend it.
	- A while later another guy called Rich Harris came along in this space with something called Svelte and oh, did he put the cat amongst the pigeons with this. He totally re-thunk the whole idea of front end framework implentation and took a radically different approach to the way in which the front end JavaScript app is delivered. React, being the dominant framework in the space currenlty, relies heavily on something called the 'virtual DOM'. This was a way to make rendering web pages in the browser more efficient where by the 'document object model' ( DOM ) of the browser, this is the logical state that the browser uses to positin text and images on the page that we see as a 'web page', is represented by the application in a memory and when things need to be changed, this 'virtual dom' can be used to make the changes in memory and then the browser can be told to update the DOM in the browser. This is a simplification of what is going on but it is a good enough explanation for our purposes here. Svelte on the other hand does not use this approach and instead uses a compiler to generate the code that is needed to make the changes in the browser. This is a radical departure from the way things are done and is a very interesting approach.
	- APIs are something I will never stop learning about as they are the things that front apps use to be interactive and without which would nto be able to function, so selecting the right framework to develop APIs in is critical. Picking one which is as some may say 'opinionated', that is, guides or restricts the developer into a way of working that follows best practice can help get to market faster sometimes and can mean making something that is more resilient and robust, even more maintainable and easier to work with over time. So NestJS has to be on the list for this kind of activity.
	- Another tool is FastAPI, another framework similiar in purpose to that of NestJS but rather, written in Python, so if your invested in learning only one language and that is Javascript, FastAPI is not you but if your polyglot, like me, then you can consider either in this regard. It has a quick startup and less steep learning curve that NestJS arguably but I think that NestJS has a lot more to offer in the long run. I like in both that type safety is a feature and that they both use the OpenAPI specification to document the APIs that are created. This is a standard that is used to describe APIs and is a good thing to use as it is a standard that is well known and understood and can be used to generate code for clients that use the APIs.
- {{renderer :wordcount_}}
	- with all these tools flying around, you'd think that all we have to do is just pick the right one and we're off to the races
	- I would, with a pinch of salt, agree with this but there is a lot more to it than that, of course there is. If it were that simple, we'd all want one and you could find people everywhere creating amazing applications and services that would make the world a better place. Sometimes, this does happen and you can point to major breakthroughs and market distruptors that have give us things like Google maps, remember that? It was pretty rad when it came to the for and not long following it was Google docs. 
		- google maps distrupted an entire industry set up around satalite navigation systems many of us had in our cars. It didnt happen straigt away, as google maps were just, well, maps but when they added the capability of route planning and made this available in mobile apps, you no longer needed buy an expensive sat-nav for the car, just a cradle to put you phone into. Modern cars have android built in now and you can use google maps in the car, so the industry has been distrupted and the old players have had to adapt or die. The world has got a bit better and accurate navigation is no longer the preserve of commodity hardware that benefit their manufacturers with built in revenue streams.
		- google docs changed the way we saw software. Period. Up to this point Microsoft had everyon in a vice like grip of having to pay $300 or more to even open a word doc. Now, you could edit your documents in a web browser and over night, the monopoly was smashed into bits and years later, Micrsoft had to change their business model to compete. The world got a bit better and traditional software vendors had to adapt or die.
	- Life isnt allways a bed of roses though and the reality of day to day tech rangling is a series of small attempts to do a thing, find you can't do that thing because the tools you have chosen just dont work, they have major bugs, are missing things that are promissed but not yet available. Often tools have dependencies, other things that they need in order to work but those 'third party dependencies' are often created by bodies completely separate to each other and surpise, surprise, they just dont talk to each other in perfect harmony. You quickly find out for example, that the latest flavour of the month, Typescript, the brain child of Microsoft and which anyone reading the docs would be convinced can only be a good thing due to its adding type saftey to a language that is loosely typed, JavaScript, will solve the worlds problems. What could go wrong ? Turns out, no one can really agree on the right approaches to this and already there are vast swathes of code, millions of lines of the stuff, all still in plain old JavaScript. React is one of these. The solution was for type libraries to be contributed by the community so we can import these alongside our react apps and have type safe react apps with all the benefites of code completions and all would be good in the wood. But it doesnt work out like that, often complex types are well, rather complex and as many parts of large frameworks employ complex apis and return types, React is no different. As it was not developed with Typescript in mind, incorporating Typescript into your projects can be little short of a nightmare, if you get anal over the odd 'any' type remaining in your code just to stop the typescript compiler from bleating at you. 
	- This is just a sample and there are many more. Fortunately now, I can use several different languages. If you can't and your stuck knowing just the one, lets say one that is old and much forgotten now, Perl, as I am less likely to offend as many that still may have dedication to a cause, you could  be looking for a solution to creating dynamic server side content management. Dont we all. But at one time, you might find yourself yolked to the frameworks of the time, Catalyst was one such when I was still working with Perl. Catalyst was a great idea and a very flexible tool for creating really complex web applications, all be it back end only as front end wasn't really a thing then as it is now. The problem Catalyst had though was they kept re-writing it and its apis were never backwards compatible so if you had code from 6 months ago, there would be no hope of making it work now as all your code would break, at run time, with little or no chance of understanding why. Documentation just couldnt keep up and despite the communities proud reputation on CPAN fo having the best track record for testing, somehow this got totally overlooked with frameworks like Catalyst. Over time, other framworks came to replace this, one called Mojolicious which seemed to learn from the mistakes of Catalyst. I used this quite a lot and created many successeful solutions using it but for the rot had set in. I'd been burnt by frameworks but most of all I had been burnt by a language that itself was not type safe, as I found Go to be as I started to write in more than 1 language. 
	- Another consideration to choosing a framework or language is the amount of people working on it. Javascript is something that runs on more platforms than any other in the known world. This is a fact, as they say. I think that this is reasonable to say as there are more mobile phones and 'edge' devices that can run JavaScript that could ever be said of even Java. Perl never got a lookin but it and other languages tried in this regard with browser add ons that gave the browser extra powers to execute code in languages that are not JavaScript. But most of these have failed, so we are left with JavaScript, like it or no, despite it making you feel all wrong inside because it isnt your favourite language to program in, yet its hear to stay and likely will be for a long time. 
	- There are technologies that are with us rignt now, WebAssembly is now built in to all modern browsers and this means that 'WASM' code can be created in more or less any modern language which is then used to cross compile WASM. this can be run natively then on any browser that supports it and much faster than JavaScript. 
	- Ironically, in order to get out a standard that all browsers could implement and in time for it to be of use to everyone, the WASM standard was released without some key features, one being memory management, more specifically, garbage collection. 
	- Garbage collection is something programmers rely on, heavily, to avoid memory mis-managment in which, for one, unnallocated memory can be addressed by bad actors. The classic 'buffer overflow' attack is one such example of this, in which an attacker uses the interface to a program to send more data than the program is expecting and this overflows the buffer, the memory allocated to the program to store the data, and this can be used to execute code that the attacker has injected into the buffer. This is a very common attack vector and is one of the reasons why we have to keep updating our software, to patch these holes. So langues that have garbage collection together with memory management are a good thing as they take this away from the programmer and do it for them in a way that is more predictable and less prone to error.
	- Rust doesnt have memory management, it uses something else called 'borrowing' which is a way of managing memory that is more predictable and less prone to error. So, you'd think, we'd all go over to Rust but of course, many are still heavily invested in other languages having spent years building applicaitons in them and they are not going to just drop everything and start again in Rust.
	- Whilst Rust has a lot of features the purists will like, it still has a realatively high learning curve in order for people ot become productive in it. 
	- And the other elephant in the room is, how many poeple are writing in it. Javascript programmers clearly out number thost that write in Rust, so you only have to do the numbers and it becomes pretty clear which technology is likely to win out. 
	- So you can't make something happen, even if its the best way to do a thing. In order to pick a framework, library or language, you have to consider, will I be able to do what I need to in sufficient time and with appropirate effort and make a profit from it. If you can't, then you need to look at other options.