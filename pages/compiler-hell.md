- {{renderer :wordcount_}}
	- 101 learning to program I was taught that error messages in our code are important. That they should be firstly there. Non programmers likely do not fully appreciate that it is possible, in some languages more than others but in most to write code that can go down a wrong path and fail with a variety of unexpected, to that of the user, entirely unexpected outcomes.
	- To the run time, the outcome of a memory dump, a stack trace scrolling off the end of the screen, a flashing cursor in the screen where you would expected a screen of well formatted screen estate, now surrounded by flashing numbers, characters from outer spacd and colours of the rainbow.
	- Other times, the famouse 'blue screen of death', that of the windows operating system, or the 'kernel panic' of the linux operating system. The blue screen of death ofcourse is more common, due to the sheer numbers of Windows and NT based systems at that time.
	- I new one I became aware of, quite painfully for me at the time was 'the white screen of death' programming Wordpress. I'm not certain why I never came across such untill I did, as up to then I had been programming CGI scripts without frameworks that were supposed to help you along in the process and had learnt to swim in the copious errors that these environments would yield in logs, on the consele and in the browser itself.
	- Chrome browser tools were not a thing then, so you couldnt examine the browser console for errors, you had to rely on the server logs and the browser itself.
	- I think all I had done was to edit a function in a theme. The entire web site returned immediately, no spinny wheel in the browser, no error message in the page, just a white screen.
	- You can get a bit panicky at this point and start to think you can't fix this, you perhaps shouldnt be doing this at all in fact, perhaps you chose the wrong career path, and the mind can go further down a path of deep despair and anxiety.
	- Compiliing the kernel, in Linux was not just something people did for kicks back in the day, before Y2K. It was often born out of sheer necessity. If you had a SCSI card ( Small Computer System Interface ) and a SCSI hard drive, you would need to compile the kernel to include the driver for the SCSI card, and the file system driver for the SCSI hard drive, if it were not already supported in the kernel. I remember something called something like an Adaptec 5400 or similar being the card I needed to get working and I'd never compiled a kernel in my life before. Code that I had written or downloaded from the internet, yes, but not a kernel.
	- Back then, linux operating systems did not have yet any mature package management so in the case of slackware, you downloaded archive files in the tar format ( tape archive ) and extracted them into the root directory of somewhere under /src or /usr/src. It had to be in the write place amidst the other source code files, or the kernel would not compile.
	- There were make files, which are like a recipe for compiling the code, and you would run a make command to compile code but the linux distribution came with a 'cursors' text based menu system that would guide you through the process of compiling the kernel but this was primitive and you had to know what you were doing. Things improved over time ofcourse and whilst the same or similar exists on many Linux distributions today, it is much more user, or should I say, developer friendly.
	- Error messages from the compiler were at best useless to most novices.
	- My 'favourite' so to speak was `Error: 1` amidst a sea of random gibberish. It was at this point I realised that pretty much no effort had been put into error handling in the code from which this had come from. I was not alone, I was not an ignorant, unworth savage that should not have been there and had not earnt the right to be doing anytyhing technical.
	- When the company called RedHat came about, they made a lot of changes to the way Linux was built, introducing 'RPM' ( RedHat Package Manager ) and a lot of other things that made it easier to install and manage software on Linux. They also made a lot of changes to the kernel, and the way it was compiled. One thing they did in their infinite wisdom was to swap out the gcc compiler at one poing and subsequently, unless you knew what you were doing, you would get a lot of errors when trying to compile the kernel. Most folks that started looking into Linux at this point were often put off when they then needed to compile a kernel to get something working and it would not compile, my favrouite error message being `Error: 1` might even pop up at this point.
	- Search engines and Stack Overflow did not exist yet, so searching many different sources, on line forums, email lists and so forth was the only way to get help.
	- The 'problem' went away when the gcc compiler was swapped back in, but it was a good example of how arbritary changes can have a huge impact on the user experience, even going as far as putting some people off using something entirely.
	- A tactice I still employ to get past the wall of these kinds of problems that could have the potential to drive one insane is to break the system of sofware down to its parts and test each in isolation, to then introduce or re-introduce the change or modification that caused the problem in the first place, and then to test again. This way it can be possible to  isolate the problem and to get to the root cause of the mind numbingly frustrating error conditions.
	- Sometimes, the can mean an entire application, that could have taken weeks, months, to write, suddenly failing, apparently in a catastrophic manner, simply by introducint a single module, called by a sinlgle line of code. I've just come across such only recently, again. Will this ever stop ?
	- A package that is designed, ironically as it is designed to gather crash reports, itself crashed my application, causing there to be a 'white screen' where the normal user interface would be expected, no other activity, no error message, no log entry, nothing. So it happens today as it happened, copiously in the past.
	- This is now described as 'bad dx' or 'bad developer experience' and is something that is given a lot more attention now than before and is addressed by some, more than others. I find where there are open standards and large communities, there is more attention given to this than where there are not and that with systems with closed eco systems, there is less attention given to this than where there are not. Apple is a good example of this right now, despite their slick marketting and the common belief amongst their faithful users, their developer experience is not good. Microsoft were terrible in this regard, allowing for others to perform badly in the past in my view, but they have improved a lot in this regard, and are now a good example of how to do it right in many more ways than they were before.
	- Open source tools and languages have literally died out due to bad developer experience, where as ones that made delopers lives productive and enjoyable have flourished.
	- There is one other path to consider when you get problems that you think of as insurmountable. No, perhaps two, aside of the 'breaking it down' principle. I was going to say, ask for help but I often don't do that before I walk away and have a think, even sleep and go back to it the next day when the cortisol has lowered a bit and you can think more clearly.
	- Then, there can be a point where you have to ask for help. And that can be quite daunting, I know. Not because you are afraid of being found out for not knowing what your doing, not that, we all have to get past that, its called learning and we never stop in this venture, or should not. In fact, the more we know, the more we realise we dont know, so knowing more typically leads to feeling like you know less if anything. No, it can simply be the flame response you may get if the question has been asked between 1 or 1000 or more times before, take you pick. So first of all, before asking anything, check that someone else has asked this before. 9 times out of then, they have and three is at least a thread of where to get started on a path to solving your particular issue. If this still does not work, at least you can say 'I've tried all these and still, this is the problem, with details so that people can understand what has been tried and what has not. Its also a good idea to say please and thankyou, basic manners as should be in all communications, but often are not, even though you may feel frustrated and angry.
	- And now, today, in this year of 2023 we have AI. And this changes all the things. There is a chat bot we can talk to and it can tell us answers that we could simply not do with a search engine and had to wait for days, possibly weeks for an answer back from a forum.
	- And perhaps another strategy for dealing with mind bendingly insane difficulties brought to us by the companies and corporations, the communiites and ecosystems of every more complicated sofware and solutions that are growing exponentially around us is to account for the fact that some things are just going to take time and have a level of complexity that cannot be avoided, so planning for this and not giving out false promises and hopes as to how soon a thing can be delivered is the only way to make something out of the madness.
	- If we are truly honest with ourselves and, based on experience, can make a value judgement on a particular project or idea, before we start or predict how long something will take, we can objectively decide if a thing is worth doing or not. If it is, then be honest about the time and effort a thing will take and dont give out false promises. 'Manage expectations' is the phrase I think
	- If we can be informed and honest how long it can take to do a thing, we can also look at the ways in which that thing can be accomplished. There are often many diffent ways soluitons in software can be developed from the languages that are used to the frameworks or libraaries or both to the patterns or methodologies that are used when writing software, even the ways in which we manage large projects. But for small projects, involving just 1 person doing the work or just a handful, many of the same decision making processes can be applied.
	- Lanugages and frameworks, like companies or organisations can have influencers and money behind them. There is a tendency today to invent a new framework or library apparetnly on a weekly basis it would seem sometimes and finally, now some are starting to comment on this and to call it out.
	- So even though a lot of people seem to be saying that somehting must have our attention and we simply must learn this thing right now or do something this way, right now, it can sometimes be a good idea to just take a step back and assess the realy benefits of doing so, if it is not blindingly obvious already.
	- There area and always will be intellectual arguments that take place between adherents of one technology, language or framework over another. Often, either of two or more approoaches will work and sometimes it can be a preference of one over the other, or a matter of what is available to you at the time. Ones point of view is another to consider and if you are time poor and have to get results fast, not having a team of people to do the work for you, you may have to make a decision based on what you know and what is available that can do the job, rather than exploring unknowns with brand new technologies that may or may not deliver as they have simply not been done before.
	- It may mean that you have to make compromises and choose less 'purist' technologies or approaches, but if it gets the job done and can be completed a lot more quickly.
- {{renderer :wordcount_}}
-